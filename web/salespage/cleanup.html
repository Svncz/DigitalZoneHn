<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Cleanup Duplicates</title>
</head>

<body>
    <h1>Cleaning up Duplicates...</h1>
    <div id="status">Scanning...</div>
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, getDocs, deleteDoc, doc, orderBy, query } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        const firebaseConfig = {
            apiKey: 'AIzaSyC2b9MJwrTxKrlm_9iNMc_ihQfrb0uKAOI',
            appId: '1:656121260272:web:2f047725ff149aaaf57a35',
            messagingSenderId: '656121260272',
            projectId: 'digitalzonehn',
            authDomain: 'digitalzonehn.firebaseapp.com',
            storageBucket: 'digitalzonehn.firebasestorage.app',
            measurementId: 'G-VG2BC64R4G',
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        async function cleanup() {
            const statusDiv = document.getElementById('status');
            try {
                // Get all products ordered by creation time (so we keep the oldest)
                const q = query(collection(db, 'products'), orderBy('createdAt', 'asc'));
                const snapshot = await getDocs(q);

                const seenNames = new Set();
                let deletedCount = 0;

                for (const d of snapshot.docs) {
                    const data = d.data();
                    const name = data.name;

                    if (seenNames.has(name)) {
                        // Duplicate! Delete this one (since it's newer due to 'asc' order, wait... actually we want to keep oldest. 
                        // If we iterate asc, the first one encountered is oldest. It goes into Set.
                        // Subsequent ones with same name are newer duplicates.
                        await deleteDoc(doc(db, 'products', d.id));
                        statusDiv.innerHTML += `<br>Deleted duplicate: ${name} (${d.id})`;
                        deletedCount++;
                    } else {
                        seenNames.add(name);
                    }
                }

                if (deletedCount === 0) {
                    statusDiv.innerHTML += "<br>No duplicates found.";
                } else {
                    statusDiv.innerHTML += `<br><strong>Deleted ${deletedCount} duplicates.</strong>`;
                }
                statusDiv.innerHTML += "<br><strong>Cleanup Done!</strong>";
                document.title = "Cleanup Complete";

            } catch (e) {
                statusDiv.innerHTML += `<br>Error: ${e.message}`;
                console.error(e);
            }
        }

        cleanup();
    </script>
</body>

</html>